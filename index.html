<!DOCTYPE html>
<html>
  <head>
    <title>Parcel Sandbox</title>
    <meta charset="UTF-8" />
  </head>

  <body>
    <div id="app"></div>
    <canvas width="380" height="160"></canvas>

    <script>
      const canvas = document.querySelector("canvas");
      const CTX = canvas.getContext("2d");

      const cellBoundaryPath =
        "M0 80.954C0 51.64 21.5 14.865 53 7.5 87.452-.555 118.061 1 153.226 1 198.529 1 260.839 5.124 312 9.5c38.609 3.302 68 40.941 68 75.494 0 39.247-32.985 78.645-78.5 74.506-44.469-4.043-89.804-7.763-129.887-7.763-33.017 0-55.544.952-87.113 4.263C37.391 160.941 0 125.911 0 80.954z";
      const cellBoundaryPathObject = new Path2D(cellBoundaryPath);
      let dotLocation = { x: 50, y: 50 };
      let heading = 15;
      let speed = 3;
      let dotSize = 4;

      // helpers
      const nextPositionAlongHeading = (position, speed, headingInDeg) => ({
        x: position.x + speed * Math.cos(headingInDeg * (Math.PI / 180)),
        y: position.y + speed * Math.sin(headingInDeg * (Math.PI / 180))
      });

      const randomBetween = (min, max) => Math.random() * (max - min) + min;

      // test all corners of a square against a boundary
      const isShapeInPath = (path, location, size) =>
        CTX.isPointInPath(path, location.x, location.y) &&
        CTX.isPointInPath(path, location.x + size, location.y) &&
        CTX.isPointInPath(path, location.x + size, location.y + size) &&
        CTX.isPointInPath(path, location.x, location.y + size);

      // recurse until new location inside boundary is found
      const getNewLocationInBoundary = () => {
        return new Promise((resolve) => {
          const prospectiveNewLocation = nextPositionAlongHeading(
            dotLocation,
            speed,
            heading
          );

          if (
            !isShapeInPath(
              cellBoundaryPathObject,
              prospectiveNewLocation,
              dotSize
            )
          ) {
            heading = randomBetween(1, 360);
            return resolve(getNewLocationInBoundary());
          } else {
            return resolve(prospectiveNewLocation);
          }
        });
      };

      // animation cycle
      const drawFrame = () => {
        // fill in background
        CTX.fillStyle = "black";
        CTX.fillRect(0, 0, canvas.width, canvas.height);

        // fill in cell shape
        CTX.fillStyle = "gray";
        CTX.fill(cellBoundaryPathObject);

        // fill in dot
        getNewLocationInBoundary().then(({ x, y }) => {
          dotLocation = { x, y };
          CTX.fillStyle = "red";
          CTX.fillRect(x, y, dotSize, dotSize);
        });

        window.requestAnimationFrame(drawFrame);
      };

      window.requestAnimationFrame(drawFrame);
    </script>
  </body>
</html>
